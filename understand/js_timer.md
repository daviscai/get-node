## 理解定时器

`Javascript执行是单线程的，主线程的语句和方法，会阻塞定时任务的运行，只有在执行完主线程的代码后，定时任务才会实际执行，这期间的时间，可能大于注册任务时设置的延时时间。`

上面这句话道出了Javascript定时器的问题和产生的原因，说白了，就是定时器不一定准时(按时)执行。

### 事件循环模型
在理解定时器之前，我们需要了解JS运行时（node.js或者浏览器）的执行机制。

由于JS运行时(Runtime)是单线程，所以同一时间只能执行一个任务，其他任务就得排队，后续任务必须等到前一个任务结束才能开始执行。

为了避免因为某些长时间任务造成的无意义等待，JS引入了异步的概念，用另一个线程来管理异步任务。

同步任务直接在主线程栈中顺序执行，而异步任务会进入另一个任务队列，不会阻塞主线程。等到主线程栈空了（执行完了）的时候，就会去异步队列查询是否有可执行的异步任务，如果有就将其加入主线程栈中执行，以此循环，这就是`Event loop事件循环机制`。 如下图：  

![](../imgs/event-loop2.png)

上图中，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在"事件队列"中加入各种事件（click，load，done）。`只要栈中的代码执行完毕，主线程才会去读取"事件队列"`，依次执行那些事件所对应的回调函数。

`Event Loop是实现异步的一种机制`，主线程永远在执行中，会不断检查事件队列。



> 事件驱动的的实现过程主要靠事件循环完成。进程启动后就进入主循环。主循环的过程就是不停的从事件队列里读取事件。如果事件有关联的handle(也就是注册的callback)，就执行handle。一个事件并不一定有callback  
-- 来自扑灵的评注

### setTimeout
setTimeout(fn, x)表示延迟x毫秒之后执行fn，但并不一定是在x毫秒后准时执行，有时候甚至会比预期要晚几秒，这个取决于事件循环队列里的各个事件执行情况和主线程的繁忙程度。

下面来看一个例子
```
(function testSetTimeout() {
    const label = 'setTimeout';
    console.time(label);  // 启动一个计时器
    setTimeout(() => {
        console.timeEnd(label);  // 停止一个通过 console.time() 启动的计时器
    }, 10);
    for(let i = 0; i < 100000000; i++) {}
})();

//输出
setTimeout: 190ms
```

我们设置的延时时间是10毫秒，但实际延时时间是190毫秒，可以说，实际时间总是比设置的大。

### setInterval
setInterval(fn, x)表示间隔x毫秒重复执行fn，实际间隔时间跟设置的时间不一样。

对于setInterval(fn, 100)容易产生一个误区：并不是上一次fn执行完了之后再过100ms才开始执行下一次fn。 事实上，setInterval并不管上一次fn的执行结果，而是每隔100ms就将fn放入主线程队列，而两次fn之间具体间隔多久就不一定了。

看看下面例子：
```
(function testSetInterval() {
    let i = 0;
    const start = Date.now();
    const timer = setInterval(() => {
        i += 1;
        i === 5 && clearInterval(timer);
        console.log(`第${i}次开始`, Date.now() - start);
        for(let i = 0; i < 100000000; i++) {}
        console.log(`第${i}次结束`, Date.now() - start);
    }, 100);
})();
```
输出：
```
第1次开始 100
第1次结束 798
第2次开始 799 <-
第2次结束 1492
第3次开始 1492 <-
第3次结束 2192
第4次开始 2194 <-
第4次结束 2885
第5次开始 2886 <-
第5次结束 3579
```

可见，虽然每次fn执行时间都很长，但下一次并不是等上一次执行完了再过100ms才开始执行的，实际情况是上一次执行完马上就执行下一次了，完全没有等待100ms再执行。


### 轮播图的怪异问题
曾经有个业务需求是做轮播图，页面上至少3个以上定时器（多个轮播模块，均由不同的业务方实现），而其中一个轮播模块里会调用我负责的模块，我负责的模块里又有轮播图，尝试过多个轮播方案，在IE低版本环境下，会出现轮播顺序错乱，间隔时间失效等问题，而且最重要的是偶现，不是必现。

解决的措施：
1. 减少定时器，采用中央定时器，由中央定时器管理不同的轮播模块，包括统一创建定时器，及时清除定时器，防止命名冲突
2. 避免在页面加载时触发过多的事件，非立即执行事件做延时异步处理setTimeout(fn, 0)
3. 对mouseover,mouseout事件避免事件冒泡，防止多次触发

### 参考
http://blog.csdn.net/lin_credible/article/details/40143961
http://www.alloyteam.com/2016/05/javascript-timer/  
http://www.alloyteam.com/2015/10/turning-to-javascript-series-from-settimeout-said-the-event-loop-model/
